# 遗留代码单元测试(讲义)

> 遗留代码就是没有测试的代码。

## 为什么要给遗留代码增加单元测试？

1. 构建安全网，增强修改代码时的信心，因为一旦改出问题，单元测试就会失败。
2. 减少人工回归测试的工作量，执行几百个单元测试只用不到一秒钟。
3. 为了编写测试而修改的代码会更容易扩展，是代码更容易响应变化，更容易维护。
4. 代替其它成本较高的自动化测试，虽然大多数时候需要对代码进行改动，但成本仍然较低。

## 遗留代码单元测试的难点

绝大多数情况下，遗留代码在编写之时就不会考虑测试，基本不具备可测试性。常见的困难有：

1. 被测逻辑在私有方法里，测试不能直接调用。
2. 被测方法没有返回值，也没有可访问的副作用，无法用期望值验证结果。
3. 被测方法代码太长太复杂，设计测试用例很困难。

   - 一个面向过程式的超大方法完成所有功能
   - 包含许多嵌套条件分支的方法

   > 方法体多长算长？

4. 被测方法代码的依赖难以或无法构造，准备测试 Fixture 很困难

   - 用到了由框架创建并传入的参数、从基类继承的 final 成员变量、单例。
   - 执行过程中调用了其他的私有方法

因此，要对遗留代码增加单元测试，首先要提升被测方法的可测试性，这就需要对被测方法/类进行**重构**，或提升方法可见性级别，或将被测方法分而治之，或暴露可以改变依赖行为的**接缝**。

> 重构是指在**不改变代码外部行为**的同时对代码内部结构进行调整，达到简化和提升可读性的目的。
>
> 代码外部行为在不同的粒度有不同的表现形式：
>
> 1. 作为服务，对外暴露的是协议接口(与编程语言无关)
> 2. 作为库/模块。对外暴露的是公有类和公有方法
> 
> 外部行为是否被破坏需要（自动化）测试来验证

但是，没有足够自动化测试保障的情况下，贸然对遗留代码进行重构毫无疑问有风险，所以要特别谨慎。

## 选择恰当的时机

选择恰当的时机进行重构，避免贸然修改代码带来的风险，最大化重构和单元测试的 ROI。

合适的时机：

- 在对遗留代码的功能进行扩展和修改时，在不破块原有功能的前提下进行重构，并为代码原有的功能加上单元测试。
- 从遗留代码中提取可重用的代码块时，逐步重构，为提取出的可复用功能加上单元测试

不合适的时机：

- 重写的成本远低于重构。不如重写时及时加上单元测试。
- 遗留代码能够满足需要，没有修改的必要。不必浪费增加任何测试。

## 做好充分的准备

1. 仔细阅读被测代码及文档，或找其他同事了解，深入理解其功能和实现。
2. 刻意联系并熟练掌握 IDE 提供的“安全”自动重构功能和一些解依赖的方法。
3. 约上一个同事结对，在重构和编写测试时多一份保障，多一些思路。
4. 先增加一些粗粒度的成本较低的测试(如接口测试)进行对被测代码最重要的功能进行保护。

## 小步前进，为遗留代码加上单元测试

第一步，**改造方法**：提升方法可见性，或使用重构手法分解过长的被测方法  
第二步，**暴露接缝**：增加可以注入依赖的“接缝”  
第三步，**构造依赖**：使用重构手法降低依赖构造的复杂度  
第四步，**编写测试**：创建被测类并注入依赖，对提取出的方法编写单元测试  
第五步，**整理代码**：对有测试保障的代码进一步重构，消除重复，提升代码可读性。

重复上述五个步骤，进行下一轮的重构和测试。

> 条件满足可以跳过中间步骤，或者合并几个重构步骤

## 分解动作

### 第一步，方法改造

对方法的改造有：

1.  移动临时变量声明位置。

    **适用情况**：

        临时变量的声明和作用域之间还有其他代码逻辑，不适合作为同一个方法提取

2.  通过提取方法分解过长方法。

    **可以提取成方法的代码片段**：

        - 条件分支
        - 用注释分割的代码段
        - 循环体

3.  通过提取方法消除重复代码。

    **适用情况**：

        同样或者相似的代码逻辑在同一个方法或者同一个类或子类中反复出现。

    **注意事项**：

        往往先要将重复代码中的不同部分通过**提取临时变量**和**提取方法**剥离出去。再使用提取方法将重复的代码逻辑提取成方法。

### 第二步，暴露接缝

> “接缝”是指在不修改代码的条件下，可以改变代码行为的地方。每一个“接缝”都对应着一个“激活点”，“激活点”决定了代码的行为。

代码中常见的“接缝”和“激活点”有：

1. 作为依赖被注入的接口或抽象类，通过注入不同的依赖来改变行为，接口的不同实现就是激活点。

   > _即使依赖不是接口或抽象类，依然可以通过 mock 来实现"激活点"_

   常见的依赖注入方式：

   - 参数注入
   - 构造方法注入
   - Setter 注入
   - 注入框架

2. 可以被重写的基类成员，通过子类对基类的重写实现不同的逻辑，子类重写的实现就是激活点。

暴露接缝的重构手法有：

1.  提取方法参数

    **适用情况**：

        方法中使用的任何变量都可以使用该手法进行提取。

    **注意事项**：

        * 不能破坏原有方法的签名(一般不会直接修改原方法，而是增加一个新方法)
        * 方法参数过多导致代码可读性下降的坏味道(采用后面其它几种重构方法)

2.  增加带参数的构造方法

    **适用情况**：

        方法依赖的成员变量直接在无参数构造方法中初始化。且成员变量构造困难

3.  使用 Getter 访问成员变量

    **适用情况**：

        方法中直接使用了成员变量，但成员变量不能注入(如在无参构造函数中创建的final成员变量)。测试时可以构造子类重写Getter方法提供返回值。

4.  使用方法代替临时变量

    **适用情况**：

        方法中直接使用了临时变量，构造复杂无法替换(如单例或者静态工厂方法发)。可以将构造逻辑提取成一个成员方法，返回该临时变量。这样子类可以重写该方法返回不同的实例。

### 第三步，构造依赖

1.  直接构造依赖对象

    **适用情况**：

        简单 POJO 对象，有工厂方法，或者 Builder 方法。

2.  使用 Mock

    **适用情况**：

        非 final 类的对象。如果依赖的使接口或者抽象类，应该 mock 接口或抽象类，而不是 mock 具体实现类。

3.  提取接口或抽象类

    **适用情况**

        被测对象只是使用了依赖的一个或几个方法。可以提取一个接口或者抽象类，将这些方法作为接口方法或者抽象方法。

    **注意事项**

        原来方法的签名可能发生变化(参数类型有由具体类型变为接口或者抽象类)。

4.  增加包装类

    **适用情况**：

        静态工厂方法或者单例构造的依赖。创建一个新的包装类将该依赖包装起来。使方法依赖新的包装类。

    **注意事项**

        原来方法的签名可能发生变化(参数类型变为包装类型)。

### 第四步，编写测试

> 见《单元测试基础》

### 第五部，整理代码

1.  重命名

    **适用情况**：

        新方法名、变量名不能表达准确的含义。

    **注意事项**：

        一般不修改原方法的名字(而是给原方法加上 @Deprecated)。

2.  增加注解

    **适用情况**：

        - 决定后续不再使用的方法加上 @Deprecated，并增加注释
        - 增加 ＠NonNull @Nullable 等提示非空或可空的参数

3.  移动方法

    **适用情况**：

        方法中的依赖几乎来自同一个外部对象，该方法和这个对象联系更紧密。

4.  使用方法对象代替方法

    **适用情况**

        方法依赖很多且只有该方法使用。
